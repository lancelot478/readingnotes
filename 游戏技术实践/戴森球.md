# ~~[宇宙生成](https://indienova.com/indie-game-development/dyson-sphere-devlog-2/)~~


其实，我们一直都在马不停蹄的开发《戴森球计划》，工作实在太多，时间又实在太少了，每天都感觉被时间追着跑，一刻都不敢耽误，还有一大堆内容没做完。唉，此刻又陷入深深的焦虑中。

《戴森球计划》从题材上来说，是一款模拟经营游戏，那模拟的是什么，经营的又是什么呢。在解释这个之前，我先和大家说说戴森球。戴森球，是弗里曼·戴森在 1960 年就提出的一种理论，是一种太空巨构，它完全包围恒星并且获得其绝大多数或全部的能量输出。在我们设定中，就需要建造戴森球为超级计算机——“主脑”提供能量以维持强大的计算能力。

建造戴森球需要消耗大量的资源，因此 COSMO 派遣机甲探索宇宙，寻找资源，为新的戴森球建造原材料基地，但仅仅一个星球上的资源肯定是不够的，这就需要经营一个更庞大的跨星系自动化基地了。

![](https://hive.indienova.com/farm/blog/2019/12/u-3448645641696gvo.jpg_webp)

如何实现星际间自动化？其实，在游戏的设定中，需要建立星际物流网络，把不同星球上的工厂串联成一个庞大的工业帝国。为了实现这种星系之间的连接，我们在设计和技术实现上做了很多的探讨，最终确定了方向——要想星际自动化，首先就必须要有宇宙，有了宇宙，一切设计才有了基础。

#### 如何生成宇宙模型

在这部分开发日志里，我主要分享一下我们游戏中宇宙是如何设定的。

首先，我们需要确定的是，游戏中模拟的宇宙范围到底是多大。大家都知道，实际的宇宙无限大，如果我们以真实的宇宙范围作为参考来模拟游戏中的宇宙的话，估计游戏是做不完了，但如果把宇宙范围设定得太小的话，又会偏离最初的设计意图。那么，怎么才能让玩家既能感受到宇宙的浩瀚，又能体验到游戏的趣味性呢？这个问题苦恼了我们很久，我们知道必须在设计上做一些取舍。经过不断的讨论，最后我们秉着一切从游戏性出发，形式追随功能，将游戏中星系设定在星区这个级别。

![图片来源于维基百科](https://hive.indienova.com/farm/blog/2019/12/u-34486456417321Qo.jpg_webp "图片来源于维基百科")

图片来源于维基百科

要想模拟宇宙，就不可避免地要对每颗恒星的性质进行设定。我们都知道，每个星区都包含了不同种类的恒星，而每种类型的恒星都有自己的特性，这些都是要有科学依据的，不可能想当然的假设，不然就会站不住脚。因此，整个宇宙模型的推演必须要建立在恒星规律的基础之上。现在，我就和大家分享一下我们是怎么推演的。

赫罗图（Hertzsprung-Russell diagram），是丹麦天文学家赫茨普龙及美国天文学家罗素提出的，是恒星的光谱类型与光度的关系图。从赫罗图中，我们可以看到绝大多数的恒星位于从上方到右下方的对角线窄带内，这条带就是主星序，其中的恒星就是主序星，大概占恒星总数的 80%~90%。我们在恒星类型的设定时，也参考了这个比例，将大多数恒星设定为主序星，也就是大家熟悉的太阳，同时我们也设计了一些红巨星、中子星、黑洞等。

![](https://hive.indienova.com/farm/blog/2019/12/u-3448645641826Ie8.png_webp)

图片来源于维基百科

从游戏设计的角度来看，我们不可能把恒星的实际质量及规律真实还原，更需要考虑的是游戏性。为了设定恒星的质量，我们做了一些假定：恒星质量的对数大致呈正态分布，以 A 型恒星的质量作为正态分布的平均值，分布在左侧都是红黄色恒星，分布在右侧都是蓝紫色恒星。整个设定的实现逻辑如下图，通过这个逻辑推演便可以设定每颗恒星的质量。当然为了游戏性，在满足科学的基础上，我们在游戏中对恒星的质量做了一些修正。

![](https://hive.indienova.com/farm/blog/2019/12/u-34486456419134Zh.jpg_webp)

在恒星特性设定过程中，我们发现恒星的特性，尤其是恒星的光度和表面温度，非常强地依赖于恒星的质量。因此，在设定恒星的一些特性时，我们基本上是以恒星的质量作为设定基础。当然，恒星的性质是相当复杂的，我们在游戏中不可能设定完所有特性，只选择了一些和游戏核心玩法相关的特性。在这里，我简单分享几个恒星性质设定的推演逻辑：

![](https://hive.indienova.com/farm/blog/2019/12/u-3448645641937EZD.jpg_webp)

在游戏的设定中，有 O（蓝色）、B（蓝白色）、A（白色）、F（黄白色）、G（黄色）、K（橙色）、M（红色）七种不同类型的恒星，每种类型的恒星质量也各不相同，总的来说，O 型恒星质量最大，M 型恒星质量最小，而且质量大的恒星颜色比较明亮，而且温度很高，而质量小的恒星颜色比较暗淡，温度也比较低。

![](https://hive.indienova.com/farm/blog/2019/12/u-3448645642031qVY.jpg_webp)

当然，如果只是简单的按照设定模拟每颗恒星，整个画面的色彩过渡会显得很不自然，因此就需要做一些色彩上的调整。我们根据恒星特性与质量之间的关系，在 Unity 中对恒星的颜色做了进一步的参数设置， 包括恒星主体颜色、光晕的颜色、光照颜色、日落的颜色等等。最后，我们在调色盘中调了上百种颜色，才生成出所有类型的恒星，也使恒星颜色能够合理的过渡。

![](https://hive.indienova.com/farm/blog/2019/12/u-3448645642054gqE.jpg_webp)

![](https://hive.indienova.com/farm/blog/2019/12/u-3448645642060Ao6.jpg_webp)

在设定完恒星的特性之后，我们开始思考如何根据恒星的特性确定行星的分布。蓝色的 O 型恒星的质量很大，而且温度很高，那我们设定它的行星分布大多数是熔岩星球，而红色的 M 型恒星质量小，而且温度很低，那它的行星分布大多数则是冰冻星球。

行星类型的分布确定之后，现在我们需要考虑的是，一个星系到底生成几颗行星比较合适呢。为了增加游戏的趣味性，我们必须随机每个星系的行星数量。目前，我们设定的每个星系随机生成 1~6 颗行星，当然包含气态行星在内，同时每颗气态行星至少有一颗固态行星类的卫星，具体有多少颗卫星，就看这个星系设定的总的行星数量了。

为了确定行星的类型，我们设定每颗恒星有 16 条不同的运行轨道，而生成的行星则随机分布在不同的轨道上。每条轨道的大小不一样，而且每颗恒星适合居住的区域大小（Habitable）也不一样。行星的类型取决于所在的轨道以及是否处于 Habitable 内，如果轨道在 Habitable 里，那大概率则是海洋星球；若轨道不在 Habitable 内，那么越靠近恒星的，大概率是熔岩星球，反之越远的则大概率是冰冻星球；若都不是这几种类型的星球的话，那就大概率会是荒漠星球了。就这样，我们利用程序算法确定了不同轨道上的行星类型。

![](https://hive.indienova.com/farm/blog/2019/12/u-3448645642185B5g.gif)

在设定完恒星及行星的特性之后，我们需要随机生成星系的形状，这样才能保证每个玩家的每一局新游戏都是不同的体验。关于星系形状的生成算法，我们选择了常用的柏林噪声算法（Perlin Noise）。柏林噪声是一个非常强大的算法，经常用于程序生成随机内容，比如地形，火焰燃烧特效 ，水和云等等。从下面的柏林噪声图中可以看到，涂色区域的恒星会比较密集，其他区域则会相对稀疏一些。

![](https://hive.indienova.com/farm/blog/2019/12/u-3448645642222u0t.jpg_webp)

哦，差点忘了，我们还需要给每颗恒星取名字。说起取名字，真的是让我们开发组哭笑不得。我们所有恒星的名字都是用程序算法把英文字母随机排列组合，刚开始随机出来的怎么看都不像是个名字，有的还超级搞笑。后来经过不断的优化，才让恒星的名字有那么一点像样了。下面这个就是现在游戏里做好的星系图，我录了个 Gif 给大家分享一下。

![](https://hive.indienova.com/farm/blog/2019/12/u-34486456422708EP.gif)

我们知道，宇宙模拟模型的设定中存在很多不足的地方，在之后开发的过程中，我们会尽最大努力去完善，不管是从游戏性还是科学性，都希望能够做得更好。说到这里，发现《戴森球计划》还有好多内容啊。额，不说了，我继续摸鱼去了，下次再和大家分享~

#### 美术资源制作：树

做了两棵树和几种石头的模型，再也不用看之前丑丑的树了。

![](https://hive.indienova.com/farm/blog/2019/11/u-3448643826588k1d.gif)

![](https://hive.indienova.com/farm/blog/2019/11/u-34486438268454x1.png_webp)

关于树的动画，我们用了一种很神奇的方法——给树叶的每个顶点涂上不同的颜色，然后用 shader 把这些顶点颜色的 RGB 变成运动方向的 XYZ，这样树叶就能动啦~

```
v.vertex.xyz += (v.color.rgb - 0.5)  * (sin(time + 0.65) * cos((2 + v.color.r) * time - 0.5) * cos(3 * time + 0.5) + sin(20 * time) * 0.05) * _Anim;

// 原理是利用几个正弦波的叠加模拟树叶的摆动
```

![](https://hive.indienova.com/farm/blog/2019/11/u-3448643826701Ewm.png_webp)

![](https://hive.indienova.com/farm/blog/2019/11/u-3448643826254X14.gif)

另外，我们利用 shader 重置了树叶的法线，使得树叶整体看起来毛茸茸的，感觉还不错哦~

```
float3 std = normalize(v.vertex.xyz);
v.normal.xyz = lerp(v.normal.xyz, std, _LerpNormal);
v.normal = normalize(v.normal);

//原理是将树叶的顶点法线指向整个树的外侧
```

![](https://hive.indienova.com/farm/blog/2019/11/u-34486438269635sa.png_webp)

# [优化](https://indienova.com/indie-game-development/dyson-sphere-devlog-4/)


目前这个存档的游戏时间是 **118** 小时。

游戏玩到后期卡吗？这也许是大家最关心的问题之一。

数千艘运输机在忙碌，数千座设施在运作，数万个太阳帆在环绕，数十万货物在运送，斗转星移，地面上所有太阳能板都面朝着太阳… 这计算量可不是闹着玩的！而以上还只是这一个星球。

本篇我将主要介绍为了保证游戏的流畅性，我们是如何实现游戏性能优化的。由于该话题涉及的内容与技术细节实在太多，所以我打算将优化系列分为三篇开发日志，粗略的谈一下我们所用的方法与技术。

#### 游戏的帧率机制

游戏中的帧率分为**渲染帧**和 **物理帧** ：

渲染帧主要负责渲染游戏画面；

物理帧主要负责运行游戏逻辑。

![](https://hive.indienova.com/farm/blog/2020/12/u-34486493851388GV.png_webp)

我们在游戏中制作了帧率计数器以监控实时性能，其中左边的数字是渲染帧，右边的数字是物理帧。也可以在设置面板中设定渲染帧的帧速率。当开启垂直同步时，渲染帧速率会和显示器刷新率一致。

![](https://hive.indienova.com/farm/blog/2020/12/u-3448649385172VlT.png_webp)

帧速率越高，GPU 的使用率也就越高，当使用率接近 `100%` 时，就会自动降低画面帧率。

在游戏的生产系统中，我们需要一套能精确量化，服从“决定论”的逻辑，即同样的操作只能导致同样的结果。要抛开帧率带来的影响，首先是游戏中所有的时间必须按物理帧计数，例如制造时间为 `3` 秒的“电弧熔炉”，其实在内部逻辑里就是 `180` 个物理帧。再例如 `360kW` 的工作功率，在内部逻辑里其实是每个物理帧消耗 `6kJ` 的能量，颇有一种“量子化”的感觉。

![](https://hive.indienova.com/farm/blog/2020/12/u-3448649385206jHL.png_webp)

根据以上的逻辑，负责游戏逻辑的物理帧必须相对稳定，不能被渲染帧率所影响，否则玩起来就会感觉时间一会快，一会慢，所以我们将物理帧率锁定为 `60` 帧，只有当渲染帧率太低时，才会折减物理帧率，以免塞帧。

#### 使用 DOP 来代替 OOP

`DOP` 和 `OOP` 分别指“面向数据编程”和“面向对象编程”。具体的比较可以写好长一篇文章，而且前人已充分讨论，所以这里就不赘述了。简单来讲，在面对游戏中大量物件的情况下，面向对象会造成许多不必要的开销，造成性能低下，而面向数据编程则将对象中的属性逐一拆分出来，形成紧密排列的数组，使得相关逻辑能够更快速的进行遍历，甚至一些数据还能直接传给 GPU 来处理。

那么为什么大家不都用 `DOP` 来代替 `OOP` 呢？这是因为“面向对象”更符合人们的认知和代码书写习惯，也便于项目管理，而“面向数据”的代码写起来有一些反人类，有时甚至相似的结构写好几遍，不方便管理，但实际运行效率却极高。所以为了游戏的优化，我们还是选择了“面向数据”来作为该项目的编程核心思想与框架。

读起来太晦涩了吗？那实在不行的话我们就这样吧！

![](https://hive.indienova.com/farm/blog/2020/12/u-3448649385231nR6.jpg_webp)

不开玩笑了，回到正题

物理帧的大部分工作是由 CPU 来完成的，要维持 `60` 的帧率，一个物理帧允许的 CPU 处理时间不能超过 `16ms`（毫秒），除开提交 `DrawCall` 渲染的时间和其他必须的开销，只有大约 `11ms` 可用于一帧的游戏核心逻辑。

#### 单核游戏？多核游戏？都不是，这是一个 GPU 游戏！

目前 CPU 的性能发展遇到了瓶颈，已经没办法再大规模提升单核性能，只能靠提升核心数量。而在很多实际应用的情况下，对核心数量的提升，远不如增加一点点单核频率提升的性能多。

虽然我们在星系的随机生成及模拟、星球地形动态生成、无缝加载等逻辑中使用了多线程来缓解主线程的压力，但是对于游戏逻辑中如此庞大的计算量，就算有 `100` 个核火力全开多线程完美配合也未必驾驭得了！

从《戴森球计划》的想法诞生之初，就决定了这是一个 GPU 游戏。看那数万颗太阳帆，每一颗的运动都遵循着万有引力定律，每一颗都在计算发电量，每一颗都能被近距离观看。像大规模并行计算这样的工作，使用 GPU 是不二的选择。

![](https://hive.indienova.com/farm/blog/2020/12/u-3448649385261894.png_webp)

我们将凡是可以并行计算的那部分计算工作，全部交给了 GPU，剩下的那部分计算量，只要 GPU 能在 `16ms` 之内按时渲染出来，CPU 就绝不会掉链子！

这同时也意味着，好的 GPU 的确能为《戴森球计划》带来更流畅的体验，而 CPU 的影响则相对较小。

#### 使用 GPU 来渲染大批量动画

在现今主流游戏引擎中，动画大多是靠移动部件或骨骼的位置（Position）、旋转（Rotation）、缩放（Scale）来完成的，如下图：

![](https://hive.indienova.com/farm/blog/2020/12/u-3448649385307Ew4.gif)

该建筑的动画是靠旋转移动部件来完成

就是这样一个建筑，它的动画部件已超过 `50` 个，其中还包括父子 `Transform` 层级的嵌套，假设我们有 `1000` 个这样的建筑，那 CPU 需要同时处理的动画子部件就有超过 `50000` 个，这显然是 CPU 驾驭不了的，而这还仅仅只是建筑动画，并不是核心逻辑。

![](https://hive.indienova.com/farm/blog/2020/12/u-3448649385337iS1.png_webp)

用 CPU 去逐一计算这 `50000` 个部件的 Transform 的确是相当不划算的，这些动画其实可以并行计算，只要在画面帧结束时，所有建筑的动画均就绪即可，这对于具有强大并行计算能力的 GPU 来说简直就是小菜一碟。

我们在编辑器中将这个建筑的所有动画帧中所有的顶点位置、法线等信息按照一定的顺序，事先录制在一个 `VERTA` 文件中。

![](https://hive.indienova.com/farm/blog/2020/12/u-3448649385360xC6.png_webp)

当游戏加载时，只需要载入这些文件，通过 `ComputeBuffer` 将所有信息传递给 GPU，这样 GPU 就拿到了所有建筑动画的预烘焙信息，接下来再将每个建筑的动画状态组成一个数组，传给 GPU。

![](https://hive.indienova.com/farm/blog/2020/12/u-3448649385379GLV.png_webp)

每个建筑的动画状态数据

最后，还需要在 `vertex shader` 中分析这些数据，逐一还原每个建筑在当前帧的建模。

![](https://hive.indienova.com/farm/blog/2020/12/u-3448649385397oPF.png_webp)

在 `vertex shader` 中还原当前帧建模部分代码

![](https://hive.indienova.com/farm/blog/2020/12/u-3448649385453CJg.gif)

按照这个思路，我们成功使用 `GPU Instancing` 还原了所有建筑的动画，还顺便使用了建筑状态数据来控制建筑贴图上指示灯的开关。在动画和建筑状态更新方面，CPU 被完全解放。而在 GPU 中，仅仅只是多了 150MB 左右的显存数据用于存储所有建筑的动画数据（仅相当于几张 `4096` 贴图）与若干在 `vertex shader` 中的寻址与插值计算。可以说是一顿免费的午餐了！

#### 粒子特效

为了将特效渲染纳入上面的框架中，所有的建筑特效均无法使用引擎自带的粒子特效，必须将原本是作为粒子来渲染的特效包含在模型网格中，再使用 `shader` 来逐一实现各个建筑不同的特效需求。

![](https://hive.indienova.com/farm/blog/2020/12/u-3448649385508Mqi.gif)

特效片元在制作时就包含在模型中

在游戏中，几乎每一个不同的建筑都定制了不同的 `shader`，对于同一个建筑特效的不同片元，我们按照类别涂上不同的顶点色，哪些是辉光，哪些是要拉长的，哪些应该从下至上亮度递增，通过不同的片元顶点色，就能做不同的处理。

![](https://hive.indienova.com/farm/blog/2020/12/u-34486493855350qC.gif)

整个建筑的动作与特效在一个 shader 中实现

需要时刻朝向太阳方向的建筑，逻辑不能让 CPU 来处理。我们将建筑模型按照“底座”、“横向转动部分”、“俯仰转动部分”涂上不同的顶点色加以区分，再在 `shader` 里面计算这些顶点应该如何旋转，从而朝向目标点。

![](https://hive.indienova.com/farm/blog/2020/12/u-3448649385562QrM.png_webp)

朝向太阳的 `shader` 代码节选

有了这套机制，我们就只需要在主线程中计算好每个建筑当前的状态，形成 `ComputeBuffer`，传递给 GPU 来进行统一渲染，在这个过程中，动画、IK 朝向、特效、自发光变化等等，就统统都有了。

#### Unity Profiler 性能测试

说了这么多，直接上目前的性能测试图吧！

下面是 **100** 小时规模的存档在 Unity Profiler 里面的性能测试图

![](https://hive.indienova.com/farm/blog/2020/12/u-3448649385598t6P.png_webp)

![](https://hive.indienova.com/farm/blog/2020/12/u-3448649385605DEa.png_webp)

开发机配置

从图中可以看到，游戏主逻辑物理帧 CPU 耗时 `5.11ms`，也就是说理论上每秒可以跑到 `195` 个物理帧，所以 CPU 这边肯定是没问题，而最终画面能跑多少帧，就看 GPU 的能力了，我的卡是 660Ti，在畅玩了 **100** 小时后，还能跑上 `40` 帧，不过我们还将继续不懈的优化，争取将我这张卡的帧率提到 `60`！

除了物理帧的优化以外，我们还非常看重 C# 的垃圾回收机制的优化，因为过多的内存垃圾会导致游戏时常卡顿，严重影响游戏体验。

一般来讲，每次触发垃圾回收机制都会出现不同程度的卡顿，卡顿出现的频率取决于 `GC Alloc` 的大小，而每次卡顿的时间取决于数据结构的复杂度。

为了尽可能消除游戏卡顿现象，从立项开始，程序在数据结构上就严格把控，能用数组的地方用数组，尽量少的使用 `Dictionary` 或 `List`，凡是物理帧的逻辑除数组扩容等操作以外，均不能产生 `GC Alloc`，在 UI 逻辑中严格控制字符串的操作，避免不必要的开销。

据测试，目前游戏的 `GC.Collect` 卡顿时间已控制在 `30ms` 以内，出现频率为几乎没有。

下图为 **100** 小时规模下的 GC 性能统计：

![](https://hive.indienova.com/farm/blog/2020/12/u-3448649385674w6e.png_webp)

游戏主逻辑在物理帧上的 `GC Alloc` 为 `0`，只有 UI 上有 `132` 字节的开销，加上一些引擎必要的开销，每帧总的 `GC Alloc` 为 `5.0KB`，目前这个数值处于非常低的水平。
