# 渲染顺序

**需要注意的是，游戏性能并非Draw Call越小越好。** 这是因为决定渲染模块性能的除了Draw Call之外，还有用于传输渲染数据的总线带宽。当我们使用Draw Call Batching将同种材质的网格模型拼合在一起时，可能会造成同一时间需要传输的数据（Texture、VB/IB等）大大增加，以至于造成带宽“堵塞”，在资源无法及时传输过去的情况下，GPU只能等待，从而反倒降低了游戏的运行帧率。

那么是什么在控制这个渲染顺序呢？首先在多个相机的情况下，U3D会根据相机的深度顺序进行渲染，在每个相机中，它会根据你距离相机的距离，由远到近进行渲染，在UI相机中，还会根据你UI对象的深度进行渲染

那么我们要做的就是，对要渲染的对象进行一次规划，正确地排列好它们，规则是，按照Z轴或者深度，对空间进行划分，然后确定好每个对象的Z轴和深度，让使用同一个材质的东西，尽量保持在这个空间内，不要让其他材质的对象进入这个空间，否则就会打断这个空间的渲染顺序

在这个基础上，更细的规则有：

* 场景中的东西，我们使用Z轴来进行空间的划分，例如背景层，特效层1，人物层，特效层2
* NGUI中的东西，我们统一使用Depth来进行空间的划分
* 人物模型，当人物模型只是用一个材质，DrawCall只有1，但是用了2个以上的材质，DrawCall就会暴增（或许对材质的RenderQueue进行规划也可以使DrawCall只有2个，但这个要拆分好才行），3D人物处于复杂3D场景中的时候，我们的空间规则难免被破坏，这只能在设计的时候尽量去避免这种情况了
* 使用了多个材质的特效，在动画的过程中，往往会引起DrawCall的波动，在视觉效果可以接受的范围内，可以将特效也进行空间划分，假设这个特效是2D显示，那么可以使用Z轴来划分空间

# 打包图集

每个材质/纹理的渲染一定是会产生DrawCall的，这个DrawCall只能通过打包图集来进行优化

制作图集一般遵循几个规则：

* 从功能角度进行划分，例如UI可以划分为公共部分，以及每个具体的界面，功能上，显示上密切相关的图片打包到一起
* 不要一股脑把所有东西打包到一个图集里，特别是那些不可能同时出现的东西，它们就不应该在一个图集里，这样的图集意义不大，减少不了DrawCall，并且一个你不需要显示的图片，会一直占用你的内存，这让我非常不爽
* 注意控制图集的大小，不要让图集太大，一个超级大图集的DrawCall消耗或许顶的上十几个小图集的消耗

字符图集，在使用BMFont或者其他工具生成图片字的时候，我们往往是直接导入一大串文字，然后直接生成图片，但实际上这上面的操作也有优化空间，例如BMFont生成的图片大小，是可以设置的，有两个规则，一个规则是导出的图片尽量小，另一个是导出的图片尽量少，默认的大小应该是512×512，假设你生成的图片256×256就可以容纳，那么多做一个操作你可以节省这么多空间，另外当你输入多几个字，就导致增加一张图片时，例如1024变成2048，那么你可以考虑使用3张512的图片，这样也会节省空间

经过精心划分的图集在加上精心规划的渲染顺序，DrawCall会有一个质的优化

# 特效清理

U3D提供了非常便捷的方法让我们很轻易地使用美术给过来的特效，懒惰的U3D程序猿会直接放入U3D，甚至不去看这是个什么特效，我们的特效一般都是一瞬间的事情，例如技能特效，或者其他什么特效，那么特效播放完，这个特效我们就看不到了，但假设这个特效在播放结束的时候，没有将自身的Active属性设置为false，那么它就会继续占用你的DrawCall，消耗你设备的计算能力，所以程序需要保证当一个特效播放完之后，能够被消耗，或者设置为非激活的状态，可以使用一些公共方法来完成特效播放完之后的清理工作（自己实现2个静态函数，一个播放完销毁，一个播放完设置未激活）

# 批处理

在屏幕上渲染物体，引擎需要发出一个绘制调用来访问图形API（iOS系统中为OpenGL ES）。每个绘制调用需要进行大量的工作来访问图形API，从而导致了CPU方面显著的性能开销。

Unity在运行时可以将一些物体进行合并，从而用一个绘制调用来渲染他们。这一操作，我们称之为“批处理”。一般来说，Unity批处理的物体越多，你就会得到越好的渲染性能。

Unity中内建的批处理机制所达到的效果要明显强于使用几何建模工具（或使用Standard Assets包中的CombineChildren脚本）的批处理效果。这是因为，Unity引擎的批处理操作是在物体的可视裁剪操作之后进行的。Unity先对每个物体进行裁剪，然后再进行批处理，这样可以使渲染的几何总量在批处理前后保持不变。但是，使用几何建模工具来拼合物体，会妨碍引擎对其进行有效的裁剪操作，从而导致引擎需要渲染更多的几何面片。

## 材质：

只有拥有相同材质的物体才可以进行批处理。因此，如果你想要得到良好的批处理效果，你需要在程序中尽可能地复用材质和物体。

如果你的两个材质仅仅是纹理不同，那么你可以通过 纹理拼合 操作来将这两张纹理拼合成一张大的纹理。一旦纹理拼合在一起，你就可以使用这个单一材质来替代之前的两个材质了。

如果你需要通过脚本来访问复用材质属性，那么值得注意的是改变Renderer.material将会造成一份材质的拷贝。因此，你应该使用Renderer.sharedMaterial来保证材质的共享状态。

动态批处理：

如果动态物体共用着相同的材质，那么Unity会自动对这些物体进行批处理。

动态批处理操作是自动完成的，并不需要你进行额外的操作。

## Tips:

提醒：

1、批处理动态物体需要在每个顶点上进行一定的开销，所以动态批处理仅支持小于900顶点的网格物体。

2、如果你的着色器使用顶点位置，法线和UV值三种属性，那么你只能批处理300顶点以下的物体；如果你的着色器需要使用顶点位置，法线，UV0，UV1和切向量，那你只能批处理180顶点以下的物体。请注意：属性数量的限制可能会在将来进行改变。

4、不要使用缩放尺度（scale）。分别拥有缩放尺度(1,1,1)和(2,2,2)的两个物体将不会进行批处理。

5、统一缩放尺度的物体不会与非统一缩放尺度的物体进行批处理。  使用缩放尺度(1,1,1)和 (1,2,1)的两个物体将不会进行批处理，但是使用缩放尺度(1,2,1)和(1,3,1)的两个物体将可以进行批处理。

6、使用不同材质的实例化物体（instance）将会导致批处理失败。

7、拥有lightmap的物体含有额外（隐藏）的材质属性，比如：lightmap的偏移和缩放系数等。所以，拥有lightmap的物体将不会进行批处理（除非他们指向lightmap的同一部分）。

8、多通道的shader会妨碍批处理操作。比如，几乎unity中所有的着色器在前向渲染中都支持多个光源，并为它们有效地开辟多个通道。

9、预设体的实例会自动地使用相同的网格模型和材质。

## 静态批处理：

相对而言，静态批处理操作允许引擎对任意大小的几何物体进行批处理操作来降低绘制调用（只要这些物体不移动，并且拥有相同的材质）。因此，静态批处理比动态批处理更加有效，你应该尽量低使用它，因为它需要更少的CPU开销。

为了更好地使用静态批处理，你需要明确指出哪些物体是静止的，并且在游戏中永远不会移动、旋转和缩放。想完成这一步，你只需要在检测器（Inspector）中将Static复选框打勾即可，如下图所示

使用静态批处理操作需要额外的内存开销来储存合并后的几何数据。在静态批处理之前，如果一些物体共用了同样的几何数据，那么引擎会在编辑以及运行状态对每个物体创建一个几何数据的备份。这并不总是一个好的想法，因为有时候，你将不得不牺牲一点渲染性能来防止一些物体的静态批处理，从而保持较少的内存开销。比如，将浓密森里中树设为Static，会导致严重的内存开销。

静态批处理目前只支持Unity iOS Advanced。

# 性能问题总结

unity3D 对于移动平台的支持无可厚非，但是也有时候用Unity3D 开发出来的应用、游戏在移动终端上的运行有着明显的效率问题，比如卡、画质等各种问题。自己在做游戏开发的时候偶有所得。对于主要影响性能的因素做个总结。

## 主要因素

```
    1、Saved by batching 值过大--> 这个值主要是针对Mesh的批处理，这个值越高，应用就越卡   

    2、Drawcall 值过大--> Drawcall 值过大，所需要的 GPU 的处理性能较高，从而导致CPU的计算时间过长，于是就卡了

    3、点、面过多-->点、面过多，GPU 根据不同面的效果展开计算，并且CPU计算的数据也多，所以效果出来了，但是卡巴斯基
```

由于 Saved by batching 和 Drawcall 值过大所引起的卡的问题我所做的优化方式有：

* 对于模型 ：Mesh 合并，有个不错的插件（DrawCall Minimizer   --->  直接上Asset Store 下载即可，免费的，而且有文档，很容易上手）
* 对于UI  :  尽量避免使用Unity3D自带的 GUI 换用 NGUI或者EZGUI；因为这两个UI插件对于UI中的图片处理是将UI图片放置在一个 Atlas 中，一个 Atlas 对应一个Drawcall
* 对于灯光： 可以使用 Unity3D 自带的  Lightmapping 插件来烘焙场景中的灯光效果到物体材质上
* 对于场景： 可以使用 Unity3D 自带的 Occlusion Culling 插件把静止不动的场景元素烘焙出来
* 对于特效：尽量把材质纹理合并

对于Unity3D 在移动终端上支持的Drawcall 数到底多少，主要是跟机子性能有关的，当然也不是说值小性能就一定没问题（本人亲测，也有17就卡的，主要是模型材质纹理过大所引起的），目前我做的是70左右的，还OK，挺正常的

由于点、面过多所导致的性能问题，最好用简模，用四面体来做复杂的模型，但是面、点也别太多，至于Unity3D 到底支持多少点、面的说法各异，我也搞不懂，总之少些肯定OK

## 检测方式

一，Unity3D 渲染统计窗口

Game视窗的Stats去查看渲染统计的信息:

1、FPS

fps其实就是 frames per second,也就是每一秒游戏执行的帧数，这个数值越小，说明游戏越卡。

2、Draw calls

[]()batching之后渲染mesh的数量，和当前渲染到的网格的材质球数量有关。

3、[]()Saved []()by batching

渲染的批处理数量，这是引擎将多个对象的绘制进行合并从而减少GPU的开销;

很多GUI插件的一个好处就是合并多个对象的渲染，从而降低DrawCalls ，保证游戏帧数。

4、Tris 当前绘制的三角面数

5、Verts 当前绘制的顶点数

6、Used Textures 当前帧用于渲染的图片占用内存大小

7、Render Textures 渲染的图片占用内存大小，也就是当然渲染的物体的材质上的纹理总内存占用

8、VRAM usage 显存的使用情况，VRAM总大小取决于你的显卡的显存

9、VBO Total 渲染过程中上载到图形卡的网格的数量，这里注意一点就是缩放的物体可能需要额外的开销。

10、Visible Skinned Meshes 蒙皮网格的渲染数量

11、Animations 播放动画的数量

注意事项：

1,运行时尽量减少 Tris 和 Draw Calls

预览的时候，可点开 Stats，查看图形渲染的开销情况。特别注意 Tris 和 Draw Calls 这两个参数。

一般来说，要做到：

Tris 保持在 7.5k 以下，有待考证。

Draw Calls 保持在 20 以下，有待考证。

2，FPS，每一秒游戏执行的帧数，这个数值越小，说明游戏越卡。

3，Render Textures 渲染的图片占用内存大小。

4，VRAM usage 显存的使用情况，VRAM总大小取决于你的显卡的显存。

## 代码优化

1. 尽量避免每帧处理

比如：

function Update() { DoSomeThing(); }

可改为每5帧处理一次：

function Update() { if(Time.frameCount % 5 == 0) { DoSomeThing(); } }

2. 定时重复处理用 InvokeRepeating 函数实现

比如，启动0.5秒后每隔1秒执行一次 DoSomeThing 函数：

function Start() { InvokeRepeating("DoSomeThing", 0.5, 1.0); }

3. 优化 Update, FixedUpdate, LateUpdate 等每帧处理的函数

函数里面的变量尽量在头部声明。

比如：

```
function Update() { var pos: Vector3 = transform.position; }
```

可改为

```
private var pos: Vector3; function Update(){ pos = transform.position; }
```

4. 主动回收垃圾

给某个 GameObject 绑上以下的代码：

function Update() { if(Time.frameCount % 50 == 0) { System.GC.Collect(); } }

5. 优化数学计算

比如，如果可以避免使用浮点型(float)，尽量使用整形(int)，尽量少用复杂的数学函数比如 Sin 和 Cos 等等

6，减少固定增量时间

将固定增量时间值设定在0.04-0.067区间（即，每秒15-25帧）。您可以通过Edit->Project Settings->Time来改变这个值。这样做降低了FixedUpdate函数被调用的频率以及物理引擎执行碰撞检测与刚体更新的频率。如果您使用了较低的固定增量时间，并且在主角身上使用了刚体部件，那么您可以启用插值办法来平滑刚体组件。

7，减少GetComponent的调用

使用 GetComponent或内置组件访问器会产生明显的开销。您可以通过一次获取组件的引用来避免开销，并将该引用分配给一个变量（有时称为"缓存"的引用）。例如，如果您使用如下的代码：

```
function Update () {
    transform.Translate(0, 1, 0);
}
```

通过下面的更改您将获得更好的性能：

```
var myTransform : Transform;
    function Awake () {
        myTransform = transform;
    }
    function Update () {
        myTransform.Translate(0, 1, 0);
    }
```

8，避免分配内存

您应该避免分配新对象，除非你真的需要，因为他们不再在使用时，会增加垃圾回收系统的开销。您可以经常重复使用数组和其他对象，而不是分配新的数组或对象。这样做好处则是尽量减少垃圾的回收工作。同时，在某些可能的情况下，您也可以使用结构（struct）来代替类（class）。这是因为，结构变量主要存放在栈区而非堆区。因为栈的分配较快，并且不调用垃圾回收操作，所以当结构变量比较小时可以提升程序的运行性能。但是当结构体较大时，虽然它仍可避免分配/回收的开销，而它由于"传值"操作也会导致单独的开销，实际上它可能比等效对象类的效率还要低。

9，使用[iOS](http://lib.csdn.net/base/1)脚本调用优化功能

UnityEngine 命名空间中的函数的大多数是在 C/c + +中实现的。从Mono的脚本调用 C/C++函数也存在着一定的性能开销。您可以使用iOS脚本调用优化功能（菜单：Edit->Project Settings->Player）让每帧节省1-4毫秒。此设置的选项有：

Slow and Safe – Mono内部默认的处理异常的调用

Fast and Exceptions Unsupported –一个快速执行的Mono内部调用。不过，它并不支持异常，因此应谨慎使用。它对于不需要显式地处理异常（也不需要对异常进行处理）的应用程序来说，是一个理想的候选项。

10，优化垃圾回收

如上文所述，您应该尽量避免分配操作。但是，考虑到它们是不能完全杜绝的，所以我们提供两种方法来让您尽量减少它们在游戏运行时的使用：

如果堆比较小，则进行快速而频繁的垃圾回收

这一策略比较适合运行时间较长的游戏，其中帧率是否平滑过渡是主要的考虑因素。像这样的游戏通常会频繁地分配小块内存，但这些小块内存只是暂时地被使用。如果在iOS系统上使用该策略，那么一个典型的堆大小是大约 200 KB，这样在iPhone 3G设备上，垃圾回收操作将耗时大约 5毫秒。如果堆大小增加到1 MB时，该回收操作将耗时大约 7ms。因此，在普通帧的间隔期进行垃圾回收有时候是一个不错的选择。通常，这种做法会让回收操作执行的更加频繁（有些回收操作并不是严格必须进行的），但它们可以快速处理并且对游戏的影响很小：

```
if (Time.frameCount % 30 == 0)
{
       System.GC.Collect();
}
```

但是，您应该小心地使用这种技术，并且通过检查Profiler来确保这种操作确实可以降低您游戏的垃圾回收时间

如果堆比较大，则进行缓慢且不频繁的垃圾回收

这一策略适合于那些内存分配 (和回收）相对不频繁，并且可以在游戏停顿期间进行处理的游戏。如果堆足够大，但还没有大到被系统关掉的话，这种方法是比较适用的。但是，Mono运行时会尽可能地避免堆的自动扩大。因此，您需要通过在启动过程中预分配一些空间来手动扩展堆（ie，你实例化一个纯粹影响内存管理器分配的"无用"对象）：

```
function Start() {
     var tmp = new System.Object[1024];
    // make allocations in smaller blocks to avoid them to be treated in a special way, //which is designed for large blocks
    for (var i : int = 0; i < 1024; i++){
        tmp[i] = new byte[1024];
    // release reference
        tmp = null;
    }
}
```

游戏中的暂停是用来对堆内存进行回收，而一个足够大的堆应该不会在游戏的暂停与暂停之间被完全占满。所以，当这种游戏暂停发生时，您可以显式请求一次垃圾回收：

System.GC.Collect();

另外，您应该谨慎地使用这一策略并时刻关注Profiler的统计结果，而不是假定它已经达到了您想要的效果。

## 模型

1,压缩 Mesh

导入 3D 模型之后，在不影响显示效果的前提下，最好打开 Mesh Compression。

Off, Low, Medium, High 这几个选项，可酌情选取。

2,避免大量使用 Unity 自带的 Sphere 等内建 Mesh

Unity 内建的 Mesh，多边形的数量比较大，如果物体不要求特别圆滑，可导入其他的简单3D模型代替。

* DrawCall就是对底层图形程序（比如：OpenGL ES)接口的调用，以在屏幕上画出东西。所以，是谁去调用这些接口呢？CPU。
* fragment是啥？经常有人说vf啥的，vertex我们都知道是顶点，那fragment是啥呢？说它之前需要先说一下像素，像素各位应该都知道吧？像素是构成数码影像的基本单元呀。那fragment呢？是有可能成为像素的东西。啥叫有可能？就是最终会不会被画出来不一定，是潜在的像素。这会涉及到谁呢？GPU。
* batching是啥？都知道批处理是干嘛的吧？没错，将批处理之前需要很多次调用（drawcall）的物体合并，之后只需要调用一次底层图形程序的接口就行。听上去这简直就是优化的终极方案啊！但是，理想是美好的，世界是残酷的，一些不足之后我们再细聊。
* 内存的分配：记住，除了Unity3D自己的内存损耗。我们可是还带着Mono呢啊，还有托管的那一套东西呢。更别说你一激动，又引入了自己的几个dll。这些都是内存开销上需要考虑到的。

# **CPU方面的优化**

DrawCall影响的是CPU的效率，而且也是最知名的一个优化点。但是除了DrawCall之外，还有哪些因素也会影响到CPU的效率呢？让我们看看暂时能想得到的：

* **[DrawCalls](https://www.cnblogs.com/murongxiaopifu/p/4284988.html#drawcall)**
* **[物理组件（Physics）](https://www.cnblogs.com/murongxiaopifu/p/4284988.html#wuli)**
* **[GC](https://www.cnblogs.com/murongxiaopifu/p/4284988.html#GC)** （什么？GC不是处理内存问题的嘛？我要提醒一句！，GC是用来处理内存的，但是是谁使用GC去处理内存的呢？“CPU”）
* 当然，还有代码质量

DrawCalls：

```
    DrawCall是CPU调用底层图形接口。比如有上千个物体，每一个的渲染都需要去调用一次底层接口，而每一次的调用CPU都需要做很多工作，那么CPU必然不堪重负。但是对于GPU来说，图形处理的工作量是一样的。所以对DrawCall的优化，主要就是为了尽量解放CPU在调用图形接口上的开销。所以针对DrawCalls我们主要的思路就是每个物体尽量减少渲染次数，多个物体最好一起渲染。所以，按照这个思路就有了以下几个方案：
```

1. 使用Draw Call Batching，也就是描绘调用批处理。Unity在运行时可以将一些物体进行合并，或者在之前就让美工合并，从而用一个描绘调用来渲染他们。具体下面会介绍。
2. 通过把纹理打包成图集来尽量减少材质的使用，或者把所有图片能做在一张大的图片上或者几张大的图片上尽量不要超过1024。
3. 尽量少的使用反光、阴影、反射探头、灯光探头、实时灯光之类的，因为那会使物体多次渲染。

## Draw Call Batching：

首先要先理解何为2个没有使用相同材质的物体即使使用批处理，也无法实现Draw Call数量的下降和性能上的提升。

因为被“批处理”的2个物体的网格模型需要使用相同材质的目的，在于其纹理是相同的，这样才可以实现同时渲染的目的。所以必须保证材质相同，是为了保证被渲染的纹理相同。

如果两个不同网格模型需要处理提升性能，就将2个纹理不同的材质合二为一，我们就需要把两个不同的纹理在外部结合或者，将纹理打包成图集。达到合二为一这种情况，就是将2个纹理合成一个纹理。这样我们就可以只用一个材质来代替之前的2个材质了。

而Draw Call Batching本身，也还会细分为2种。

### Static Batching 静态批处理：

场景中不动的网格模型道具，楼房......那和什么比较类似呢？场景的属性很像！所以我们的场景似乎就可以采用这种方式来减少DrawCall。

那么写个定义：只要这些物体不移动，并且拥有相同的材质，静态批处理就允许引擎对任意大小的几何物体进行批处理操作来降低描绘调用。

那要如何使用静态批来减少Draw Call呢？你只需要明确指出哪些物体是静止的，并且在游戏中永远不会移动、旋转和缩放。想完成这一步，你只需要在检测器（Inspector）中将Static复选框打勾即可，如下图所示：

![](https://img-blog.csdnimg.cn/20190524091519740.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3JmMTk0NQ==,size_16,color_FFFFFF,t_70)

运行后的效果好不好？

举个例子：创建几个模型，分别是Cube，Sphere, Capsule, Cylinder,它们有不同的网格模型，但是也有相同的材质（Default-Diffuse）。

首先，我们不指定它们是static的。Draw Call的次数是5次，如图：

![](https://img-blog.csdnimg.cn/20190524092030505.png)

将它们4个物体都设为static，在来运行一下：

![](https://img-blog.csdnimg.cn/2019052409223941.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3JmMTk0NQ==,size_16,color_FFFFFF,t_70)

```
    如图，Draw Call的次数变成了2，而Bactched Draw Calls:的次数变成了4, Batches的次数变成了1
```

静态批处理的好处很多，其中之一就是与下面要说的动态批处理相比，约束要少很多。所以一般推荐的是Draw Call的静态批处理来减少Draw Call的次数。

```
    那么接下来，我们就继续聊聊Draw Call的动态批处理。
```

### Dynamic Batching 动态批处理:

```
    首先要明确一点，Unity3D的Draw Call动态批处理机制是引擎自动进行的，无需像静态批处理那样手动设置static。我们举一个动态实例化prefab的例子，如果动态物体共享相同的材质，则引擎会自动对draw call优化，也就是使用批处理。首先，我们将一个模型做成prefab，然后再实例化500次，看看Draw Call的数量。
```

```
for (int i = 0; i < 100; i++) {
            GameObject player = GameObject.Instantiate(playerPrefab) as GameObject;
            player.transform.position = new Vector3(Random.Range(4, -4), 0, Random.Range(4, -4));
        }
```

DrawCall的数量:

![](https://img-blog.csdnimg.cn/20190524121754438.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3JmMTk0NQ==,size_16,color_FFFFFF,t_70)

可以看到draw call的数量为2，而 saved by batching的数量是99。而这个过程中，我们除了实例化创建物体之外什么都没做。不错，unity3d引擎为我们自动处理了这种情况。

大部分同学也遇到这种情况，就是我也是从prefab实例化创建的物体，为何我的draw call依然很高呢？这就是我上文说的，draw call的动态批处理存在着很多约束。下面就演示一下，针对cube这样一个简单的物体的创建，如果稍有不慎就会造成draw call飞涨的情况吧。

我们同样是创建100个物体，不同的是其中的100个物体，每个物体的大小都不同，也就是Scale不同。

```
 for (int i = 0; i < 100; i++) {
            GameObject player = GameObject.Instantiate(playerPrefab) as GameObject;
            if (i / 100 == 0) {
                player.transform.localScale = new Vector3(Random.Range(4, -4), 4, Random.Range(4, -4));
            }
        }
```

![](https://img-blog.csdnimg.cn/20190524122106436.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3JmMTk0NQ==,size_16,color_FFFFFF,t_70)

我们看到draw call的数量上升到了85次，而saved by batching的数量也下降到了16。各位看官可以看到，仅仅是一个简单的cube的创建，如果scale不同，竟然也不会去做批处理优化。这仅仅是动态批处理机制的一种约束，那我们总结一下动态批处理的约束，各位也许也能从中找到为何动态批处理在自己的项目中不起作用的原因：

1. 批处理动态物体需要在每个顶点上进行一定的开销，所以动态批处理仅支持小于900顶点的网格物体。
2. 如果你的着色器使用顶点位置，法线和UV值三种属性，那么你只能批处理300顶点以下的物体；如果你的着色器需要使用顶点位置，法线，UV0，UV1和切向量，那你只能批处理180顶点以下的物体。
3. 不要使用缩放。分别拥有缩放大小(1,1,1) 和(2,2,2)的两个物体将不会进行批处理。
4. 统一缩放的物体不会与非统一缩放的物体进行批处理。
5. 使用缩放尺度(1,1,1) 和 (1,2,1)的两个物体将不会进行批处理，但是使用缩放尺度(1,2,1) 和(1,3,1)的两个物体将可以进行批处理。
6. 使用不同材质的实例化物体（instance）将会导致批处理失败。
7. 拥有lightmap的物体含有额外（隐藏）的材质属性，比如：lightmap的偏移和缩放系数等。所以，拥有lightmap的物体将不会进行批处理（除非他们指向lightmap的同一部分）。
8. 多通道的shader会妨碍批处理操作。比如，几乎unity中所有的着色器在前向渲染中都支持多个光源，并为它们有效地开辟多个通道。
9. 预设体的实例会自动地使用相同的网格模型和材质。

所以，尽量使用静态的批处理。

### 物理组件:

```
    做塔防类游戏的时候需要在单元格上排炮阵，而要侦测到哪个装备在哪个格子我选择使用了射线，由于装备单位很多，而且为了精确每一帧都会执行检测，那时候CPU的负担很重。后来我果断放弃了这种做法，并且对物理组件产生了心理的阴影。
```

这里我只提2点我感觉比较重要的优化措施：

1.设置一个合适的Fixed Timestep。设置的位置如图：

![](https://img-blog.csdnimg.cn/20190524123123380.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3JmMTk0NQ==,size_16,color_FFFFFF,t_70)

设置到多少“合适”呢？首先我们要搞明白Fixed Timestep和物理组件的关系。物理组件，或者说游戏中模拟各种物理效果的组件，最重要的是什么呢？计算啊。对，需要通过计算才能将真实的物理效果展现在虚拟的游戏中。那么Fixed Timestep这货就是和物理计算有关的啦。所以，若计算的频率太高，自然会影响到CPU的开销。同时，若计算频率达不到游戏设计时的要求，有会影响到功能的实现，所以如何抉择需要各位具体分析，选择一个合适的值。

2.就是不要使用网格碰撞器（mesh collider）：为啥？因为实在是太复杂了。网格碰撞器利用一个网格资源并在其上构建碰撞器。对于复杂网状模型上的碰撞检测，它要比应用原型碰撞器精确的多。标记为凸起的（Convex ）的网格碰撞器才能够和其他网格碰撞器发生碰撞。各位上网搜一下mesh collider的图片，自然就会明白了。我们的手机游戏自然无需这种性价比不高的东西。

当然，从性能优化的角度考虑，物理组件能少用还是少用为好。

## 处理内存，却让CPU受伤的GC:

```
    在CPU的部分也说了GC，虽然GC是用来处理内存的，但的确增加的是CPU的开销。因此它的确能达到释放内存的效果，但代价更加沉重，会加重CPU的负担，因此对于GC的优化目标就是尽量少的触发GC。

    首先我们要明确所谓的GC是Mono运行时的机制，而非Unity3D游戏引擎的机制，所以GC也主要是针对Mono的对象来说的，而它管理的也是Mono的托管堆。 搞清楚这一点，你也就明白了GC不是用来处理引擎的assets（纹理、音效、等等）的内存释放的，因为U3D引擎也有自己的内存堆而不是和Mono一起使用所谓的托管堆。其次我们要搞清楚什么东西会被分配到托管堆上？就是引用类型。比如类的实例，字符串，数组等等。而作为int，float，包括结构体struct其实都是值类型，它们会被分配在堆栈上而非堆上。主要对象就是类实例、字符串、数组这些了。
```

那么GC什么时候会触发呢？两种情况：

1. 首先当然是我们的堆的内存不足时，会自动调用GC。
2. 其次呢，作为编程人员，我们自己也可以手动的调用GC。

所以为了达到优化CPU的目的，我们就不能频繁的触发GC。而上文也说了GC处理的是托管堆，而不是Unity3D引擎的那些资源，所以GC的优化说白了也就是代码的优化。那么匹夫觉得有以下几点是需要注意的：

1. 字符串连接的处理。因为将两个字符串连接的过程，其实是生成一个新的字符串的过程。而之前的旧的字符串自然而然就成为了垃圾。而作为引用类型的字符串，其空间是在堆上分配的，被弃置的旧的字符串的空间会被GC当做垃圾回收。
2. 尽量不要使用foreach，而是使用for。foreach其实会涉及到迭代器的使用，而据传说每一次循环所产生的迭代器会带来24 Bytes的垃圾。那么循环10次就是240Bytes。
3. 不要直接访问gameobject的tag属性。比如if (go.tag == “human”)最好换成if (go.CompareTag (“human”))。因为访问物体的tag属性会在堆上额外的分配空间。如果在循环中这么处理，留下的垃圾就可想而知了。
4. 使用“池”，以实现空间的重复利用。
5. 最好不用LINQ的命令，因为它们会分配临时的空间，同样也是GC收集的目标。而且我很讨厌LINQ的一点就是它有可能在某些情况下无法很好的进行AOT编译。比如“OrderBy”会生成内部的泛型类“OrderedEnumerable”。这在AOT编译时是无法进行的，因为它只是在OrderBy的方法中才使用。所以如果你使用了OrderBy，那么在IOS平台上也许会报错。

## 代码

```
    代码质量是基于一个前提的：Unity3D是用C++写的，而我们的代码是用C#作为脚本来写的，那么问题就来了~脚本和底层的交互开销是否需要考虑呢？也就是说，我们用Unity3D写游戏的“游戏脚本语言”，也就是C#是由mono运行时托管的。而功能是底层引擎的C++实现的，“游戏脚本”中的功能实现都离不开对底层代码的调用。那么这部分的开销，我们应该如何优化呢？
```

1. 以物体的Transform组件为例，我们应该只访问一次，之后就将它的引用保留，而非每次使用都去访问。这里有人做过一个小实验，就是对比通过方法GetComponent`<Transform>`()获取Transform组件, 通过MonoBehavor的transform属性去取，以及保留引用之后再去访问所需要的时间：
   * GetComponent = 619ms
   * Monobehaviour = 60ms
   * CachedMB = 8ms
   * Manual Cache = 3ms

　　2.如上所述，最好不要频繁使用GetComponent，尤其是在循环中。

　　 3.善于使用OnBecameVisible()和OnBecameVisible(),来控制物体的update()函数的执行以减少开销。

　　 4.使用内建的数组，比如用Vector3.zero而不是new Vector(0, 0, 0);

　　 5.对于方法的参数的优化：善于使用ref关键字。值类型的参数，是通过将实参的值**复制**到形参，来实现按值传递到方法，也就是我们通常说的按值传递。复制嘛，总会让人感觉很笨重。比如Matrix4x4这样比较复杂的值类型，如果直接复制一份新的，反而不如将值类型的引用传递给方法作为参数。

# GPU的优化:

GPU与CPU不同，所以侧重点自然也不一样。GPU的瓶颈主要存在在如下的方面：

1. 填充率，可以简单的理解为图形处理单元每秒渲染的像素数量。
2. 像素的复杂度，比如动态阴影，光照，复杂的shader等等
3. 几何体的复杂度（顶点数量）
4. 当然还有GPU的显存带宽

那么针对以上4点，其实仔细分析我们就可以发现，影响的GPU性能的无非就是2大方面，一方面是顶点数量过多，像素计算过于复杂。另一方面就是GPU的显存带宽。那么针锋相对的两方面举措也就十分明显了。

1. 减少定点数量，简化计算复杂度。
2. 压缩图片，以适应显存带宽。

## 减少绘制的数目：

那么第一个方面的优化也就是减少顶点数量，简化复杂度，具体的举措就总结如下了：

* 保持材质的数目尽可能少。这使得Unity更容易进行批处理。
* 使用纹理图集（一张大贴图里包含了很多子贴图）来代替一系列单独的小贴图。它们可以更快地被加载，具有很少的状态转换，而且批处理更友好，还有不要所有的图片都合并到一个图集，尽量合并如果数据量太大DrawCall又比较低其实处理大图集也并不会很快反而还会很慢，这样GPU的显存带宽不够机器也会很慢卡顿，所以一个界面把要显示的图片都作为一个图集不需要的分开图集打包。
* 如果使用了纹理图集和共享材质，使用Renderer.sharedMaterial 来代替Renderer.material 。
* 使用光照纹理(lightmap)而非实时灯光。
* 使用LOD，好处就是对那些离得远，看不清的物体的细节可以忽略。
* 遮挡剔除（Occlusion culling）
* 使用mobile版的shader。因为简单。

## 优化显存带宽:

第二个方向呢？压缩图片，减小显存带宽的压力。

* OpenGL ES 2.0使用ETC1格式压缩等等，在打包设置那里都有。
* 使用mipmap。

MipMap

这里要着重介绍一下MipMap到底是什么。因为有人说过MipMap会占用内存呀，但为何又会优化显存带宽呢？那就不得不从MipMap是什么开始聊起。一张图其实就能解决这个疑问。

![](https://images0.cnblogs.com/blog/686199/201502/122312107765148.jpg)

*上面是一个mipmap 如何储存的例子，左边的主图伴有一系列逐层缩小的备份小图*

是不是很一目了然呢？Mipmap中每一个层级的小图都是主图的一个特定比例的缩小细节的复制品。因为存了主图和它的那些缩小的复制品，所以内存占用会比之前大。但是为何又优化了显存带宽呢？因为可以根据实际情况，选择适合的小图来渲染。所以，虽然会消耗一些内存，但是为了图片渲染的质量（比压缩要好），这种方式也是推荐的。

# 内存的优化:

```
 Unity3D运行时候的内存优化，首先要知道Unity3D游戏引擎是如何分配内存的。大概可以分成三大部分：
```

1. Unity3D内部的内存
2. Mono的托管内存
3. 若干我们自己引入的DLL或者第三方DLL所需要的内存。

第3类不是我们关注的重点，所以接下来我们会分别来看一下Unity3D内部内存和Mono托管内存，最后还将分析一个官网上Assetbundle案例来说明内存的管理。

## Unity3D内部内存：

```
      Unity3D的内部内存除了用代码来驱动逻辑，还需要对各种资源分配内存。所以简单总结一下Unity3D内部内存存放的东西吧：
```

* 资源：纹理、网格、音频等等
* GameObject和各种组件。
* 引擎内部逻辑需要的内存：渲染器，物理系统，粒子系统等等

## Mono托管内存：

unity3d游戏脚本是用C#写的，同时还要跨平台，所以带着一个Mono的托管环境显然必须的。那么Mono的托管内存自然就不得不放到内存的优化范畴中进行考虑。那么我们所说的Mono托管内存中存放的东西和Unity3D内部内存中存放的东西究竟有何不同呢？其实Mono的内存分配就是很传统的运行时内存的分配了：

* 值类型：int型啦，float型啦，结构体struct啦，bool啦之类的。它们都存放在堆栈上（注意额，不是堆所以不涉及GC）。
* 引用类型：其实可以狭义的理解为各种类的实例。比如游戏脚本中对游戏引擎各种控件的封装。其实很好理解，C#中肯定要有对应的类去对应游戏引擎中的控件。那么这部分就是C#中的封装。由于是在堆上分配，所以会涉及到GC。

而Mono托管堆中的那些封装的对象，除了在在Mono托管堆上分配封装类实例化之后所需要的内存之外，还会牵扯到其背后对应的游戏引擎内部控件在Unity3D内部内存上的分配。

举一个例子：

一个在.cs脚本中声明的WWW类型的对象www，Mono会在Mono托管堆上为www分配它所需要的内存。同时，这个实例对象背后的所代表的引擎资源所需要的内存也需要被分配。

一个WWW实例背后的资源：

* 压缩的文件
* 解压缩所需的缓存
* 解压缩之后的文件

如图：

![](https://images0.cnblogs.com/blog/686199/201502/130908209488259.png)

那么下面就举一个AssetBundle的例子：

Assetbundle的内存处理:

```
IEnumerator DownloadAndCache (){
        // Wait for the Caching system to be ready
        while (!Caching.ready)
            yield return null;

        // Load the AssetBundle file from Cache if it exists with the same version or download and store it in the cache
        using(WWW www = WWW.LoadFromCacheOrDownload (BundleURL, version)){
            yield return www; //WWW是第1部分
            if (www.error != null)
                throw new Exception("WWW download had an error:" + www.error);
            AssetBundle bundle = www.assetBundle;//AssetBundle是第2部分
            if (AssetName == "")
                Instantiate(bundle.mainAsset);//实例化是第3部分
            else
                Instantiate(bundle.Load(AssetName));
                    // Unload the AssetBundles compressed contents to conserve memory
                    bundle.Unload(false);

        } // memory is freed from the web stream (www.Dispose() gets called implicitly)
    }
}
```

内存分配的三个部分匹夫已经在代码中标识了出来：

1. Web Stream：包括了压缩的文件，解压所需的缓存，以及解压后的文件。
2. AssetBundle：Web Stream中的文件的映射，或者说引用。
3. 实例化之后的对象：就是引擎的各种资源文件了，会在内存中创建出来。

那就分别解析一下：

```
WWW www = WWW.LoadFromCacheOrDownload (BundleURL, version)
```

1. 将压缩的文件读入内存中
2. 创建解压所需的缓存
3. 将文件解压，解压后的文件进入内存
4. 关闭掉为解压创建的缓存

```
AssetBundle bundle = www.assetBundle;
```

1. AssetBundle此时相当于一个桥梁，从Web Stream解压后的文件到最后实例化创建的对象之间的桥梁。
2. 所以AssetBundle实质上是Web Stream解压后的文件中各个对象的映射。而非真实的对象。
3. 实际的资源还存在Web Stream中，所以此时要保留Web Stream。

```
Instantiate(bundle.mainAsset);
```

1. 通过AssetBundle获取资源，实例化对象

最后各位可能看到了官网中的这个例子使用了：

```
using(WWW www = WWW.LoadFromCacheOrDownload (BundleURL, version)){
}
```

这种using的用法。这种用法其实就是为了在使用完Web Stream之后，将内存释放掉的。因为WWW也继承了idispose的接口，所以可以使用using的这种用法。其实相当于最后执行了：

```
//删除Web Stream
www.Dispose();
```

OK,Web Stream被删除掉了。那还有谁呢？对Assetbundle。那么使用

```
//删除AssetBundle
bundle.Unload(false);
```

# 使用Unity Profiler工具检测内存:

Unity Profiler工具来监测内存的使用状态了。但是使用Unity Profiler工具来监测还是十分必要的，下面就简单补充一下这方面的知识。

![](https://img-blog.csdnimg.cn/201905241459478.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3JmMTk0NQ==,size_16,color_FFFFFF,t_70)

在Profiler工具中提供了两种模式供我们监测内存的使用情况，即简易模式和详细模式。在简易模式中，我们可以看到总的内存（total）列出了两列，即 **Used Total（使用总内存）** 和 **Reserved Total（预定总内存）** 。Used Total和Reserved 均是物理内存，其中Reserved是unity向系统申请的总内存，Unity底层为了不经常向系统申请开辟内存，开启了较大一块内存作为 **缓存** ，即所谓的 **Reserved内存** ，而运行时，unity所使用的内存首先是向Reserved中来申请内存，当不使用时也是先向Reserved中释放内存，从而来保证游戏运行的流畅性。一般来说，Used Total越大，则Reserved Total越大，而当Used Total降下去后，Reserved Total也是会随之下降的（但并不一定与Used Total同步）。

Unity3D的内存从大体上可以分为以下几个部分：

1. Unity：位Unity3D的底层代码所分配的内存。
2. Mono：即托管堆。Mono运行时在运行游戏脚本时所需要的内存，换句话说托管堆的大小与我们的GameObject数量、资源量无关，仅是脚本代码造成的。这部分内存是有**垃圾回收机制**的。
3. GfxDriver：可以理解为 **GPU显存开销** ，主要由Texture，Vertex buffer以及index buffer组成。所以尽可能地减少或释放Texture和mesh等资源，即可降低GfxDriver内存。
4. FMOD：音频的内存开销。
5. Profiler

而在简易模式下的监视器最下方，则列出了常见的一些资源以及它们所消耗的内存。

1. 纹理
2. 网格
3. 材质
4. 动作
5. 音频
6. 游戏对象的数量

而详细模式则需要点击“Take Sample”按钮来捕获详细的内存使用情况。需要注意的是，由于获得数据需要花费一定的时间，因此我们无法获得实时的详细内存的使用情况。在详细模式中，我们可以观察每个具体资源和游戏对象的内存使用情况。
